# Story 7.1: Task Executor Core Engine

> **Epic:** 7 - Deterministic Task Executor & Modular Agent Architecture
> **Sprint:** S6 (Week 1)
> **Priority:** P0 (core engine)
> **Points:** 13
> **Type:** Backend/Python
> **Agent:** @dev
> **Depends on:** None (foundation)

---

## Status

**Draft**

---

## Story

**As a** CNL platform developer,
**I want** a deterministic task executor that runs pre-defined steps sequentially,
**so that** safety hooks always execute and the LLM only participates where interpretation is needed.

---

## Acceptance Criteria

### Core Data Models (in `scripts/task_models.py`)

1. `TaskDefinition` dataclass with fields: `name`, `agent`, `trigger_keywords`, `risk_level`, `steps: list[StepDefinition]`, `hooks: dict`
2. `StepDefinition` dataclass with fields: `name`, `type` (tool|agent|gate), `description`, `tool`, `args_from`, `condition`, `message_template`
3. `TaskRunState` dataclass with fields: `task_id` (uuid), `task_name`, `status` (pending|running|completed|failed|rolled_back), `started_at`, `steps_completed: list[StepResult]`, `current_step`, `change_log: list[ChangeEntry]`
4. `StepResult` dataclass with fields: `step_name`, `type`, `status`, `result`, `error`, `started_at`, `completed_at`
5. `ChangeEntry` dataclass with fields: `action`, `resource_type`, `resource_id`, `backup_path`, `timestamp`
6. `TaskParseError` exception class with `file_path` and `message` fields (shared with Story 7.2)

### Task Executor Class

6. `TaskExecutor` class with `__init__(self, ai_engine, settings)` constructor
7. `execute(task_def, user_message, session_context, client_name) -> AsyncGenerator[dict, None]` — main execution loop
8. Execute steps sequentially via a `for step in task_def.steps` loop
9. Dispatcher: `step.type == "tool"` calls `execute_function()` from `executor_utils.py` (public wrapper over extracted `_execute_function`)
10. Dispatcher: `step.type == "agent"` calls `ai_engine.chat_completion()` with streaming
11. Dispatcher: `step.type == "gate"` yields `{"type": "confirmation_required", "request_id": rid, "_event": asyncio.Event()}` and awaits `event.wait()` with `asyncio.wait_for(event.wait(), timeout=300)`. WebSocket handler calls `event.set()` when user confirms.
12. Support `condition` field on steps — skip step if condition evaluates False
13. Support `args_from` field — resolve arguments from previous step results

### Hook System

14. Pre-task hooks load from `hooks/pre-task.md` or `hooks/pre-analysis.md` and execute BEFORE step loop
15. Post-task hooks load from `hooks/post-task.md` or `hooks/post-analysis.md` and execute AFTER step loop
16. Hook failure in pre-task ABORTS the task (yield error, set status=failed)
17. Hook failure in post-task logs warning but does NOT abort

### State Management

18. State saved to `clients/{client_name}/task-runs/{task_id}.json`
19. State updated after each step completion
20. On failure, state saved with `status=failed` and `current_step` pointing to failed step
21. State supports rollback: iterate `change_log` in reverse, call `rollback_config` for each entry

### Streaming Contract

22. Yield `{"type": "task_start", "task_name": ..., "total_steps": ...}`
23. Yield `{"type": "step_start", "step": step.name, "step_index": n}`
24. For tool steps: yield `{"type": "function_result", "function": ..., "result": ..., "success": ...}`
25. For agent steps: yield `{"type": "stream", "chunk": ...}` (passthrough from ai_engine)
26. For gate steps: yield `{"type": "confirmation_required", "message": ..., "request_id": ...}`
27. Yield `{"type": "step_complete", "step": step.name, "status": ...}`
28. Yield `{"type": "task_complete", "task_name": ..., "status": ..., "summary": ...}`

### Safety Layer Integration (CRITICAL — Architect Amendment)

29. Task executor integrates with existing `safety.py` functions — NOT a parallel safety system
30. Tool steps that write to the network call `safety.before_operation()` (auto-backup) before execution
31. `safety.classify_operation()` determines dynamically if a gate step is needed for tool steps not explicitly gated
32. Rollback uses `safety.execute_undo()` instead of custom change_log logic where possible
33. Document boundary: `safety.py` is the SINGLE safety authority; task executor hooks orchestrate WHEN safety functions run

### Error Handling

34. Tool step failure: yield error, save state, abort remaining steps
35. Agent step failure: retry once with simplified prompt, then abort
36. Gate step timeout (300s): yield timeout message, save state, abort

---

## Technical Notes

### Integration Points
- Import `execute_function` and `serialize_result` from `executor_utils.py` (public wrappers extracted from `agent_router.py` — MANDATORY per Architect CRITICAL-1)
- Import `AIEngine` from `ai_engine.py`
- Import safety functions: `before_operation()`, `classify_operation()`, `execute_undo()` from `safety.py`
- Import `Settings` from `settings.py`
- Import data models from `task_models.py`

### Gate Confirmation Mechanism (asyncio.Event Pattern — CRITICAL-2)
```python
# In TaskExecutor.execute():
elif step.type == "gate":
    confirm_event = asyncio.Event()
    yield {"type": "confirmation_required", "request_id": rid, "_event": confirm_event}
    # Pauses here until WebSocket handler calls confirm_event.set()
    await asyncio.wait_for(confirm_event.wait(), timeout=300)
```
The WebSocket handler must store the `_event` reference and call `event.set()` when the user sends a `confirm` message with matching `request_id`. See Story 7.3 for WebSocket modifications.

### File Location
- `scripts/task_executor.py` (~400-500 lines estimated)

### Key Design Decision
The executor does NOT own the FUNCTION_REGISTRY. It calls into existing infrastructure. This minimizes coupling and blast radius.

---

## Integration Verification

- **IV1:** TaskExecutor uses same `_execute_function()` as process_message — identical function execution path
- **IV2:** Streaming contract compatible with existing WebSocket handler in server.py
- **IV3:** State files follow same pattern as discovery snapshots (JSON in client dir)

---

## Dependencies

| Direction | Story | Title | Status |
|-----------|-------|-------|--------|
| Blocks | 7.3 | Router Integration | Draft |
| Blocks | 7.5 | Network Analyst Migration | Draft |
| Blocks | 7.6 | Meraki Specialist Migration | Draft |

---

## Tasks

- [ ] Create `scripts/task_models.py` with all shared data models (TaskDefinition, StepDefinition, TaskRunState, StepResult, ChangeEntry, TaskParseError)
- [ ] Create `scripts/executor_utils.py` — extract `_execute_function()` and `_serialize_result()` from agent_router.py as public API
- [ ] Implement TaskExecutor.__init__()
- [ ] Implement execute() main loop with step dispatcher
- [ ] Implement tool step handler (calls executor_utils.execute_function)
- [ ] Implement agent step handler (calls ai_engine.chat_completion with streaming)
- [ ] Implement gate step handler (asyncio.Event pattern — yield confirmation_required, await event.wait with 300s timeout)
- [ ] Implement safety.py integration: before_operation() in tool steps, classify_operation() for dynamic gating
- [ ] Implement pre-task hook runner
- [ ] Implement post-task hook runner
- [ ] Implement state persistence (save/load JSON)
- [ ] Implement args_from resolution between steps
- [ ] Implement condition evaluation for conditional steps
- [ ] Implement rollback via safety.execute_undo()
- [ ] Write unit tests (target: 30+ tests)
- [ ] Write integration test with mock ai_engine
- [ ] Write test for gate step asyncio.Event pause/resume

---

## File List

| File | Action | Description |
|------|--------|-------------|
| `scripts/task_models.py` | CREATE | Shared data models (TaskDefinition, StepDefinition, etc.) — MEDIUM-2 |
| `scripts/executor_utils.py` | CREATE | Public wrappers for _execute_function/_serialize_result — CRITICAL-1 |
| `scripts/task_executor.py` | CREATE | Core task executor engine |
| `scripts/agent_router.py` | MODIFY | Update _execute_function to delegate to executor_utils |
| `tests/test_task_executor.py` | CREATE | Unit + integration tests |

---

## CodeRabbit Integration

> **CodeRabbit Integration**: Enabled
> **Quality Gate**: All tests pass, no security issues, streaming contract verified
