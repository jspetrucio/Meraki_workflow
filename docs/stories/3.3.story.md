# Story 3.3: Safety Layer

> **Epic:** 3 - Multi-Provider AI Engine
> **Sprint:** S3 (Week 3)
> **Priority:** P0 (prevents accidental network damage)
> **Points:** 5
> **Type:** Backend/API
> **Agent:** @dev
> **Depends on:** Story 3.2 (Agent Prompts), Story 1.3 (Agent Router)

---

## Status

**Draft**

---

## Story

**As a** user,
**I want** the system to prevent accidental network damage,
**so that** I can use natural language configuration with confidence.

---

## Acceptance Criteria

1. All configuration changes classified as: safe (read-only), moderate (reversible), dangerous (potentially disruptive)
2. Safe operations execute immediately (discovery, reports, listing)
3. Moderate operations show preview + "Confirm" button (SSID name change, adding VLAN)
4. Dangerous operations show detailed impact analysis + require typing "CONFIRM" (firewall rule changes, ACL modifications across all networks)
5. Automatic backup created before any configuration change (using existing backup system)
6. "Undo last change" command available that triggers rollback from backup
7. Dry-run mode available: `--dry-run` flag or "what would happen if..." phrasing
8. Rate limiter prevents bulk operations from exceeding Meraki API limits

---

## Integration Verification

- **IV1:** Existing backup/rollback system in config.py works correctly through the safety layer
- **IV2:** Safety classifications don't block legitimate operations
- **IV3:** Dry-run mode produces accurate previews without side effects

---

## CodeRabbit Integration

> **CodeRabbit Integration**: Enabled
> **Profile**: assertive
> **Quality Gates**: block_on_critical=true, require_resolution=true

### Applicable Path Instructions

**`scripts/**/*.py`** (safety.py):
- CRITICAL: Safety classification must have NO bypass paths — every function call must be classified
- CRITICAL: Dangerous operations must ALWAYS create backup before execution
- CRITICAL: Rate limiter must enforce hard cap (8 req/s) — no override possible
- HIGH: Dry-run mode must guarantee zero side effects (no API calls, no file writes)
- HIGH: Undo/rollback must itself be classified as DANGEROUS (prevent accidental rollbacks)
- MEDIUM: Bulk operations must provide progress updates via WebSocket

**`tests/**/*.py`** (test_safety.py):
- VALIDATE: Every function in FUNCTION_REGISTRY has a safety classification
- VALIDATE: Dry-run produces accurate previews
- VALIDATE: Rate limiter correctly paces bulk operations
- DO NOT: Require docstrings in test functions

### Review Focus for This Story
- `SAFETY_CLASSIFICATION` dict must cover ALL functions — unclassified defaults to DANGEROUS
- Confirmation flow must be atomic — no partial execution if user cancels mid-operation
- Rate limiter must be per-organization (not global) to handle multi-org scenarios
- Backup path tracking per session must not grow unbounded (max 10 cap)

---

## Tasks / Subtasks

- [ ] **T1: Create `scripts/safety.py` — Safety classification module** (AC: 1, 2, 3, 4)
  - [ ] T1.1: Define `SafetyLevel` enum: `SAFE`, `MODERATE`, `DANGEROUS`
  - [ ] T1.2: Define `SafetyCheck` dataclass: level, action, preview, backup_required, confirmation_type
  - [ ] T1.3: Create `SAFETY_CLASSIFICATION` dict mapping function names to safety levels
  - [ ] T1.4: Safe: `full_discovery`, `discover_*`, `find_issues`, `list_*`, `generate_*`, `compare_*`, `save_snapshot`
  - [ ] T1.5: Moderate: `configure_ssid`, `enable_ssid`, `disable_ssid`, `create_vlan`, `update_vlan`
  - [ ] T1.6: Dangerous: `add_firewall_rule`, `remove_firewall_rule`, `add_switch_acl`, `delete_vlan`, `rollback_config`
  - [ ] T1.7: Implement `classify_operation(function_name: str, args: dict) -> SafetyCheck`

- [ ] **T2: Implement confirmation flow** (AC: 3, 4)
  - [ ] T2.1: Moderate: generate preview message → return `{type: "confirm", ...}` via WebSocket
  - [ ] T2.2: Dangerous: generate impact analysis → return with `confirmation_type: "type_confirm"` (user must type CONFIRM)
  - [ ] T2.3: Integrate with Agent Router: before executing function call, run `classify_operation()`
  - [ ] T2.4: If `SAFE` → execute immediately; if `MODERATE`/`DANGEROUS` → yield confirmation request

- [ ] **T3: Implement automatic backup** (AC: 5)
  - [ ] T3.1: Before any MODERATE or DANGEROUS operation, call `backup_config(network_id, client_name, config_type)` from existing config.py
  - [ ] T3.2: Store backup path in session for undo capability
  - [ ] T3.3: Track last N backups per session (max 10)
  - [ ] T3.4: Include backup path in confirmation preview: "Backup will be created at: ..."

- [ ] **T4: Implement undo/rollback** (AC: 6)
  - [ ] T4.1: Track last operation per session with backup path
  - [ ] T4.2: "Undo" or "rollback" command → Agent Router detects → call `rollback_config()` with last backup
  - [ ] T4.3: Undo itself classified as DANGEROUS (requires confirmation)
  - [ ] T4.4: Display what will be restored before executing

- [ ] **T5: Implement dry-run mode** (AC: 7)
  - [ ] T5.1: Detect dry-run intent: `--dry-run` flag, "what would happen if", "preview", "simulate"
  - [ ] T5.2: When dry-run detected, run classification and generate preview WITHOUT executing
  - [ ] T5.3: Return `{type: "data", format: "dry_run", data: {action: str, impact: str, networks_affected: int}}`
  - [ ] T5.4: Never call actual Meraki API in dry-run mode

- [ ] **T6: Implement rate limiter** (AC: 8)
  - [ ] T6.1: Track API calls per second per organization
  - [ ] T6.2: Meraki limit: 10 req/s — enforce 8 req/s to leave headroom
  - [ ] T6.3: Queue bulk operations (e.g., "apply ACL to all networks") with pacing
  - [ ] T6.4: Progress updates: `{type: "stream", chunk: "Applying to network 3/15..."}`

- [ ] **T7: Write unit tests**
  - [ ] T7.1: `tests/test_safety.py` — Test safety classification for all functions
  - [ ] T7.2: Test confirmation flow for moderate operations
  - [ ] T7.3: Test confirmation flow for dangerous operations
  - [ ] T7.4: Test backup creation before config changes
  - [ ] T7.5: Test undo/rollback mechanism
  - [ ] T7.6: Test dry-run mode (no side effects)
  - [ ] T7.7: Test rate limiter pacing
  - [ ] T7.8: Ensure all tests pass: `pytest tests/test_safety.py -v`

---

## Dev Notes

### Configuration Change Flow

[Source: architecture.md#4.3 Request Flow - Configuration Change Flow]

```
1. User: "Block telnet on all switches"
2. Agent Router → meraki-specialist
3. Agent plans changes (generates tool calls)
4. Safety Layer classifies: DANGEROUS (firewall rule across multiple networks)
5. Server sends confirmation: {type: "confirm", preview: {networks: 5, rule: "deny tcp * * port 23"}}
6. User confirms → backup_config() for each → execute → log_change()
7. Results streamed back
```

### Existing Backup System

[Source: scripts/config.py — existing functions]

- `backup_config(network_id, client_name, config_type) -> Path` — creates JSON backup
- `rollback_config(network_id, client_name, backup_path) -> ConfigResult` — restores from backup

These are called directly — the safety layer wraps around them, never modifies them.

### File Locations

| File | Location | Purpose |
|------|----------|---------|
| Safety module | `scripts/safety.py` | Classification + confirmation + rate limiting |
| Unit tests | `tests/test_safety.py` | Safety tests |

---

## Testing

- **Framework:** pytest
- **Location:** `tests/test_safety.py`
- **Coverage target:** 90%

Run tests: `pytest tests/test_safety.py -v`

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-05 | 0.1.0 | Story created from PRD + Architecture | River (SM) |
| 2026-02-05 | 0.1.1 | CodeRabbit integration enabled — assertive profile, path instructions + review focus added | River (SM) |

---

## Dev Agent Record

### Agent Model Used
_(To be filled by dev agent)_

### Debug Log References
_(To be filled by dev agent)_

### Completion Notes List
_(To be filled by dev agent)_

### File List
_(To be filled by dev agent)_

---

## QA Results
_(To be filled by QA agent)_
