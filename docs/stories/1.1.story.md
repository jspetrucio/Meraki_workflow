# Story 1.1: FastAPI Server Bootstrap

> **Epic:** 1 - API Foundation & Agent Router
> **Sprint:** S1 (Week 1)
> **Priority:** P0 (server is the host for all API + WebSocket communication)
> **Points:** 5
> **Type:** Backend/API
> **Agent:** @dev
> **Depends on:** Story 1.4 (Settings & Credential Management)

---

## Status

**Draft**

---

## Story

**As a** developer,
**I want** a FastAPI server that serves the existing Python modules as REST endpoints,
**so that** the frontend can consume discovery, config, and workflow operations via HTTP.

---

## Acceptance Criteria

1. FastAPI server starts on `localhost:3141` with CORS enabled for local development
2. Health check endpoint (`GET /api/v1/health`) returns server status, version, and uptime
3. Discovery endpoints (`POST /api/v1/discovery/full`, `GET /api/v1/discovery/snapshots`, etc.) wrap existing discovery module
4. Config endpoints (`POST /api/v1/config/ssid`, `POST /api/v1/config/firewall`, `POST /api/v1/config/acl`) wrap existing config module
5. Workflow endpoints (`GET /api/v1/workflows`, `POST /api/v1/workflows`, `GET /api/v1/workflows/templates`) wrap existing workflow module
6. Report endpoint (`GET /api/v1/reports/{client}`) serves existing HTML reports
7. Profile endpoints (`GET /api/v1/profiles`, `POST /api/v1/profiles/{name}/activate`) manage Meraki profiles via existing auth module
8. All endpoints include error handling that maps existing module exceptions to proper HTTP status codes
9. Settings routes from Story 1.4 (`scripts/settings_routes.py`) are mounted and functional
10. Static file serving for production React build (`frontend/dist/`)

---

## Integration Verification

- **IV1:** Existing CLI commands (`meraki discover`, `meraki config`) still work unchanged after server module is added
- **IV2:** Existing `clients/` directory structure is read/written correctly by API endpoints
- **IV3:** API response times are within 10% of direct CLI execution times
- **IV4:** Settings routes from Story 1.4 respond correctly when mounted on the server

---

## Dependencies

| Direction | Story | Title | Status |
|-----------|-------|-------|--------|
| Blocked by | 1.4 | Settings & Credential Management | Draft |
| Blocks | 1.2 | WebSocket Chat Endpoint | Draft |
| Blocks | 1.3 | Agent Router | Draft |
| Blocks | 2.1 | React Scaffold | Draft |

---

## CodeRabbit Integration

> **CodeRabbit Integration**: Enabled
> **Profile**: assertive
> **Quality Gates**: block_on_critical=true, require_resolution=true

### Applicable Path Instructions

**`scripts/**/*.py`** (server.py, *_routes.py — 7 route modules):
- CRITICAL: No hardcoded API keys — must use `~/.meraki/credentials` or env vars
- CRITICAL: No sensitive network data exposed in API responses (mask keys in profile endpoints)
- CRITICAL: Meraki API rate limit compliance (10 req/s per org) in all endpoint handlers
- HIGH: Error handling for all Meraki API calls (timeouts, 429 rate limits)
- HIGH: Type hints on all public endpoint functions
- HIGH: No blocking calls in async context — use `asyncio.to_thread()` for all sync module calls
- MEDIUM: Pydantic models for all request/response validation

**`tests/**/*.py`** (test_server.py):
- VALIDATE: All Meraki API calls properly mocked (never hit real API)
- VALIDATE: Error handler mapping tests (exception → HTTP status code)
- VALIDATE: Test names descriptive
- DO NOT: Require docstrings in test functions

### Review Focus for This Story
- CORS origins must be restricted to localhost only (no wildcard in production)
- Static file serving must gracefully handle missing `frontend/dist/` directory
- `asyncio.to_thread()` wrapping pattern must be consistent across all route modules
- Error responses must never expose internal stack traces (AC 8)

---

## Tasks / Subtasks

- [ ] **T1: Create `scripts/server.py` — FastAPI application skeleton** (AC: 1, 9, 10)
  - [ ] T1.1: Create FastAPI app instance with title="CNL", version from `scripts.__version__`
  - [ ] T1.2: Add CORS middleware allowing `localhost:5173` (Vite dev) and `localhost:3141`
  - [ ] T1.3: Mount settings_routes router from `scripts.settings_routes` (Story 1.4)
  - [ ] T1.4: Add static file serving for `frontend/dist/` (graceful skip if dir doesn't exist)
  - [ ] T1.5: Create `run_server()` function using uvicorn with host=`127.0.0.1`, port from settings
  - [ ] T1.6: Add startup event: log server version, port, and loaded routes
  - [ ] T1.7: Add shutdown event: clean up any active connections

- [ ] **T2: Implement health & status endpoints** (AC: 2)
  - [ ] T2.1: `GET /api/v1/health` → return `{status: "ok", version: str, uptime_seconds: float}`
  - [ ] T2.2: `GET /api/v1/status` → return connection status for Meraki, AI provider, N8N (calls SettingsManager to check)
  - [ ] T2.3: Track server start time for uptime calculation

- [ ] **T3: Implement profile endpoints** (AC: 7)
  - [ ] T3.1: Create `scripts/profile_routes.py` with FastAPI APIRouter prefix `/api/v1/profiles`
  - [ ] T3.2: `GET /api/v1/profiles` → call `auth.list_profiles()` via `asyncio.to_thread()`, return profile names
  - [ ] T3.3: `GET /api/v1/profiles/{name}` → call `auth.load_profile(name)`, return masked profile info
  - [ ] T3.4: `POST /api/v1/profiles/{name}/activate` → update settings.meraki_profile via SettingsManager
  - [ ] T3.5: Handle `CredentialsNotFoundError` → 404, `InvalidProfileError` → 400

- [ ] **T4: Implement discovery endpoints** (AC: 3)
  - [ ] T4.1: Create `scripts/discovery_routes.py` with FastAPI APIRouter prefix `/api/v1/discovery`
  - [ ] T4.2: `POST /api/v1/discovery/full` → body `{client_name: str}`, call `full_discovery()` via `asyncio.to_thread()`, return DiscoveryResult as JSON
  - [ ] T4.3: `GET /api/v1/discovery/snapshots?client={name}` → call `list_snapshots(client_name)`, return snapshot paths with timestamps
  - [ ] T4.4: `GET /api/v1/discovery/snapshots/{id}` → call `load_snapshot(path)`, return DiscoveryResult as JSON
  - [ ] T4.5: `POST /api/v1/discovery/compare` → body `{old_path: str, new_path: str}`, call `compare_snapshots()`, return diff
  - [ ] T4.6: Use Pydantic models for all request/response validation

- [ ] **T5: Implement config endpoints** (AC: 4)
  - [ ] T5.1: Create `scripts/config_routes.py` with FastAPI APIRouter prefix `/api/v1/config`
  - [ ] T5.2: `POST /api/v1/config/ssid` → body with network_id, ssid params, call `configure_ssid()` via `asyncio.to_thread()`
  - [ ] T5.3: `POST /api/v1/config/firewall` → body with network_id, rule params, call `add_firewall_rule()` via `asyncio.to_thread()`
  - [ ] T5.4: `POST /api/v1/config/acl` → body with network_id, ACL params, call `add_switch_acl()` via `asyncio.to_thread()`
  - [ ] T5.5: `POST /api/v1/config/vlan` → body with network_id, VLAN params, call `create_vlan()` via `asyncio.to_thread()`
  - [ ] T5.6: `POST /api/v1/config/rollback` → body with network_id, backup info, call `rollback_config()` via `asyncio.to_thread()`
  - [ ] T5.7: All config endpoints call `backup_config()` automatically before applying changes
  - [ ] T5.8: Return `ConfigResult` with status, details, and backup path

- [ ] **T6: Implement workflow endpoints** (AC: 5)
  - [ ] T6.1: Create `scripts/workflow_routes.py` with FastAPI APIRouter prefix `/api/v1/workflows`
  - [ ] T6.2: `GET /api/v1/workflows?client={name}` → call `list_workflows(client_name)`, return workflow list
  - [ ] T6.3: `POST /api/v1/workflows` → body with workflow type + params, call appropriate `create_*()` function, return workflow JSON
  - [ ] T6.4: `GET /api/v1/workflows/templates` → return list of available workflow template names
  - [ ] T6.5: `POST /api/v1/workflows/from-template` → call `create_*()` using template type, return workflow + import instructions

- [ ] **T7: Implement report endpoints** (AC: 6)
  - [ ] T7.1: Create `scripts/report_routes.py` with FastAPI APIRouter prefix `/api/v1/reports`
  - [ ] T7.2: `GET /api/v1/reports/{client}` → call `list_reports(client_name)`, return report paths
  - [ ] T7.3: `GET /api/v1/reports/{client}/{filename}` → serve HTML file with `FileResponse`
  - [ ] T7.4: `POST /api/v1/reports/{client}/generate` → call `generate_discovery_report()` via `asyncio.to_thread()`, return path

- [ ] **T8: Implement global error handling** (AC: 8)
  - [ ] T8.1: Create exception handlers for `CredentialsNotFoundError` → HTTP 404
  - [ ] T8.2: Create exception handlers for `InvalidProfileError` → HTTP 400
  - [ ] T8.3: Create exception handlers for `WorkflowError`, `WorkflowValidationError` → HTTP 422
  - [ ] T8.4: Create catch-all handler for `meraki.exceptions.APIError` → HTTP 502 with Meraki error detail
  - [ ] T8.5: Create generic Exception handler → HTTP 500 with safe error message (no internal stacktrace in response)
  - [ ] T8.6: All error responses follow schema: `{error: str, detail: str, code: str}`

- [ ] **T9: Add dependencies to requirements.txt** (AC: 1)
  - [ ] T9.1: Add `fastapi>=0.115.0`, `uvicorn[standard]>=0.30.0` to requirements.txt

- [ ] **T10: Write unit tests** (AC: all)
  - [ ] T10.1: `tests/test_server.py` — Test app creation, CORS headers, static file serving
  - [ ] T10.2: Test health endpoint returns correct schema
  - [ ] T10.3: Test profile endpoints with mocked auth module
  - [ ] T10.4: Test discovery endpoints with mocked discovery module
  - [ ] T10.5: Test config endpoints with mocked config module
  - [ ] T10.6: Test workflow endpoints with mocked workflow module
  - [ ] T10.7: Test report endpoints with mocked filesystem
  - [ ] T10.8: Test error handlers produce correct HTTP status codes
  - [ ] T10.9: Test settings routes are mounted and reachable
  - [ ] T10.10: Ensure all tests pass: `pytest tests/test_server.py -v`

---

## Dev Notes

### Previous Story Insights (Story 1.4)

Story 1.4 creates `scripts/settings.py` and `scripts/settings_routes.py`. The settings_routes module exports a FastAPI `APIRouter` at prefix `/api/v1` with tag `settings`. This router must be mounted by the server:

```python
from scripts.settings_routes import router as settings_router
app.include_router(settings_router)  # Already has prefix="/api/v1"
```

The `SettingsManager` from `scripts/settings.py` provides the port configuration:

```python
from scripts.settings import SettingsManager
manager = SettingsManager()
settings = manager.load()
port = settings.port  # default: 3141
```

### Module Design

[Source: architecture.md#5.1 FastAPI Server]

```python
# scripts/server.py
import time
import asyncio
import logging
from pathlib import Path
from typing import Optional

from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi.staticfiles import StaticFiles
import uvicorn

from scripts import __version__
from scripts.settings import SettingsManager
from scripts.settings_routes import router as settings_router
from scripts.profile_routes import router as profiles_router
from scripts.discovery_routes import router as discovery_router
from scripts.config_routes import router as config_router
from scripts.workflow_routes import router as workflow_router
from scripts.report_routes import router as report_router

logger = logging.getLogger(__name__)

# Server start time for uptime tracking
_start_time: float = 0.0

app = FastAPI(title="CNL", version=__version__)

# CORS for local development
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3141",
        "http://localhost:5173",  # Vite dev server
        "http://127.0.0.1:3141",
        "http://127.0.0.1:5173",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Mount routers
app.include_router(settings_router)           # /api/v1/settings/*
app.include_router(profiles_router)           # /api/v1/profiles/*
app.include_router(discovery_router)          # /api/v1/discovery/*
app.include_router(config_router)             # /api/v1/config/*
app.include_router(workflow_router)           # /api/v1/workflows/*
app.include_router(report_router)             # /api/v1/reports/*

# Static files (production React build)
frontend_dist = Path(__file__).parent.parent / "frontend" / "dist"
if frontend_dist.exists():
    app.mount("/", StaticFiles(directory=str(frontend_dist), html=True), name="static")

def run_server(host: str = "127.0.0.1", port: Optional[int] = None):
    """Start the CNL server."""
    if port is None:
        manager = SettingsManager()
        settings = manager.load()
        port = settings.port
    uvicorn.run(app, host=host, port=port)
```

### Async Boundary Pattern

[Source: architecture.md#10.3 Critical Integration Rules]

All existing Python modules are **synchronous**. FastAPI endpoints are **async**. Use `asyncio.to_thread()` to bridge:

```python
from scripts.discovery import full_discovery
from scripts.api import get_client

@router.post("/full")
async def run_full_discovery(request: DiscoveryRequest):
    # Get client (sync) → wrap in thread
    client = await asyncio.to_thread(get_client, request.profile)
    # Run discovery (sync) → wrap in thread
    result = await asyncio.to_thread(full_discovery, client.org_id, client)
    return result
```

### Error Handling Pattern

[Source: architecture.md#10.3 Critical Integration Rules]

Map existing exception types to HTTP status codes:

```python
from scripts.auth import CredentialsNotFoundError, InvalidProfileError
from scripts.workflow import WorkflowError, WorkflowValidationError
from meraki.exceptions import APIError

@app.exception_handler(CredentialsNotFoundError)
async def credentials_not_found_handler(request: Request, exc: CredentialsNotFoundError):
    return JSONResponse(status_code=404, content={
        "error": "credentials_not_found",
        "detail": str(exc),
        "code": "CRED_NOT_FOUND"
    })

@app.exception_handler(InvalidProfileError)
async def invalid_profile_handler(request: Request, exc: InvalidProfileError):
    return JSONResponse(status_code=400, content={
        "error": "invalid_profile",
        "detail": str(exc),
        "code": "INVALID_PROFILE"
    })

@app.exception_handler(APIError)
async def meraki_api_error_handler(request: Request, exc: APIError):
    return JSONResponse(status_code=502, content={
        "error": "meraki_api_error",
        "detail": str(exc),
        "code": "MERAKI_API_ERROR"
    })
```

### REST API Endpoints Catalog

[Source: architecture.md#6.1 REST API Endpoints]

Complete endpoint map that this story must implement:

| Method | Path | Wraps | Module |
|--------|------|-------|--------|
| GET | `/api/v1/health` | Server health | server.py |
| GET | `/api/v1/status` | Connection status | server.py |
| GET | `/api/v1/profiles` | `auth.list_profiles()` | auth.py |
| GET | `/api/v1/profiles/{name}` | `auth.load_profile(name)` | auth.py |
| POST | `/api/v1/profiles/{name}/activate` | `settings.update(meraki_profile=name)` | settings.py |
| POST | `/api/v1/discovery/full` | `discovery.full_discovery()` | discovery.py |
| GET | `/api/v1/discovery/snapshots` | `discovery.list_snapshots()` | discovery.py |
| GET | `/api/v1/discovery/snapshots/{id}` | `discovery.load_snapshot()` | discovery.py |
| POST | `/api/v1/discovery/compare` | `discovery.compare_snapshots()` | discovery.py |
| POST | `/api/v1/config/ssid` | `config.configure_ssid()` | config.py |
| POST | `/api/v1/config/firewall` | `config.add_firewall_rule()` | config.py |
| POST | `/api/v1/config/acl` | `config.add_switch_acl()` | config.py |
| POST | `/api/v1/config/vlan` | `config.create_vlan()` | config.py |
| POST | `/api/v1/config/rollback` | `config.rollback_config()` | config.py |
| GET | `/api/v1/workflows` | `workflow.list_workflows()` | workflow.py |
| POST | `/api/v1/workflows` | `workflow.create_*()` | workflow.py |
| GET | `/api/v1/workflows/templates` | Template list | workflow.py |
| POST | `/api/v1/workflows/from-template` | `workflow.create_*()` | workflow.py |
| GET | `/api/v1/reports/{client}` | `report.list_reports()` | report.py |
| GET | `/api/v1/reports/{client}/{file}` | FileResponse | report.py |
| POST | `/api/v1/reports/{client}/generate` | `report.generate_discovery_report()` | report.py |

### Existing Module Public APIs Used

[Source: scripts/__init__.py - existing exports]

**auth.py** — Profile management:
- `list_profiles() -> list[str]` — list available profile names
- `load_profile(name: Optional[str]) -> MerakiProfile` — load by name
- `validate_credentials(profile: MerakiProfile) -> tuple[bool, str]` — test connectivity
- Exceptions: `CredentialsNotFoundError`, `InvalidProfileError`

**api.py** — Client singleton:
- `get_client(profile: str = "default", force_new: bool = False) -> MerakiClient` — singleton client
- `MerakiClient(profile: str)` — wraps `meraki.DashboardAPI`

**discovery.py** — Network discovery:
- `full_discovery(org_id: str, client: MerakiClient) -> DiscoveryResult` — complete org discovery
- `save_snapshot(discovery: DiscoveryResult, client_name: str) -> Path`
- `load_snapshot(path: Path) -> DiscoveryResult`
- `list_snapshots(client_name: str) -> list[Path]`
- `compare_snapshots(old: DiscoveryResult, new: DiscoveryResult) -> dict`

**config.py** — Configuration:
- `configure_ssid(network_id, client, **params) -> ConfigResult`
- `add_firewall_rule(network_id, client, **params) -> ConfigResult`
- `add_switch_acl(network_id, client, **params) -> ConfigResult`
- `create_vlan(network_id, client, **params) -> ConfigResult`
- `backup_config(network_id, client_name, config_type) -> Path`
- `rollback_config(network_id, client_name, backup_path) -> ConfigResult`

**workflow.py** — Workflow creation:
- `list_workflows(client_name: str) -> list[str]`
- `create_device_offline_handler(client_name, **params) -> Workflow`
- `create_firmware_compliance_check(client_name, **params) -> Workflow`
- `create_scheduled_report(client_name, **params) -> Workflow`
- `create_security_alert_handler(client_name, **params) -> Workflow`
- `export_workflow(workflow: Workflow) -> dict`
- `save_workflow(workflow: Workflow, client_name: str) -> Path`

**report.py** — Report generation:
- `generate_discovery_report(discovery, client_name, **options) -> Report`
- `list_reports(client_name: str) -> list[Path]`
- `save_html(report: Report, output_path: Optional[Path]) -> Path`

### Pydantic Request/Response Models

[Source: architecture.md#6.1 REST API Endpoints + architecture.md#7.1 Data Models]

```python
# Shared error response
class ErrorResponse(BaseModel):
    error: str
    detail: str
    code: str

# Health
class HealthResponse(BaseModel):
    status: str  # "ok"
    version: str
    uptime_seconds: float

# Status
class StatusResponse(BaseModel):
    meraki_connected: bool
    meraki_profile: str
    ai_configured: bool
    ai_provider: Optional[str]
    n8n_connected: bool

# Profiles
class ProfileResponse(BaseModel):
    name: str
    has_api_key: bool
    has_org_id: bool

class ProfileListResponse(BaseModel):
    profiles: list[str]
    active: str

# Discovery
class DiscoveryRequest(BaseModel):
    client_name: str
    profile: Optional[str] = None  # Falls back to active profile

class SnapshotCompareRequest(BaseModel):
    old_path: str
    new_path: str

# Config
class SSIDConfigRequest(BaseModel):
    network_id: str
    client_name: str
    ssid_number: int = 0
    name: Optional[str] = None
    enabled: Optional[bool] = None
    auth_mode: Optional[str] = None
    psk: Optional[str] = None

class FirewallRuleRequest(BaseModel):
    network_id: str
    client_name: str
    policy: str  # "allow" | "deny"
    protocol: str  # "tcp" | "udp" | "any"
    dest_port: Optional[str] = None
    dest_cidr: Optional[str] = None
    comment: Optional[str] = None

class ACLRequest(BaseModel):
    network_id: str
    client_name: str
    policy: str
    ip_version: str = "ipv4"
    protocol: Optional[str] = None
    src_cidr: Optional[str] = None
    dst_cidr: Optional[str] = None
    dst_port: Optional[str] = None
    comment: Optional[str] = None

class VLANRequest(BaseModel):
    network_id: str
    client_name: str
    vlan_id: int
    name: str
    subnet: Optional[str] = None
    appliance_ip: Optional[str] = None

class RollbackRequest(BaseModel):
    network_id: str
    client_name: str
    backup_path: str

# Workflow
class WorkflowCreateRequest(BaseModel):
    client_name: str
    workflow_type: str  # "device-offline" | "firmware-compliance" | "scheduled-report" | "security-alert"
    params: Optional[dict] = None

class WorkflowTemplateRequest(BaseModel):
    client_name: str
    template_type: str
    params: Optional[dict] = None

# Report
class ReportGenerateRequest(BaseModel):
    client_name: str
    profile: Optional[str] = None
```

### File Locations

[Source: architecture.md#8 Source Tree]

| File | Location | Purpose |
|------|----------|---------|
| Server module | `scripts/server.py` | Main FastAPI app + run_server() |
| Profile routes | `scripts/profile_routes.py` | Profile CRUD endpoints |
| Discovery routes | `scripts/discovery_routes.py` | Discovery API endpoints |
| Config routes | `scripts/config_routes.py` | Config API endpoints |
| Workflow routes | `scripts/workflow_routes.py` | Workflow API endpoints |
| Report routes | `scripts/report_routes.py` | Report API endpoints |
| Settings routes | `scripts/settings_routes.py` | FROM STORY 1.4 (already exists) |
| Unit tests | `tests/test_server.py` | All server tests |

### Import Pattern

[Source: architecture.md#10.3 Critical Integration Rules]

```python
# In route files — import from existing modules
from scripts.auth import load_profile, list_profiles, CredentialsNotFoundError
from scripts.api import get_client, MerakiClient
from scripts.discovery import full_discovery, list_snapshots, load_snapshot, compare_snapshots
from scripts.config import configure_ssid, add_firewall_rule, add_switch_acl, backup_config
from scripts.workflow import list_workflows, create_device_offline_handler, export_workflow

# Async boundary for all sync calls
result = await asyncio.to_thread(sync_function, *args)
```

### Dependencies to Add

Add to `requirements.txt`:
```
fastapi>=0.115.0          # REST + WebSocket server framework
uvicorn[standard]>=0.30.0 # ASGI server for FastAPI
```

Note: `websockets` is included with `uvicorn[standard]` but the WebSocket endpoint itself is Story 1.2, not this story.

---

## Testing

[Source: architecture.md#11 Testing Strategy]

- **Framework:** pytest
- **Location:** `tests/test_server.py`
- **Coverage target:** 80%
- **Pattern:** Follow existing test patterns in `tests/test_auth.py` (class-based, mocked deps)
- **Mock strategy:** Mock all `scripts.*` module calls; never call real Meraki API in tests
- **FastAPI testing:** Use `fastapi.testclient.TestClient` for endpoint tests

```python
# Test structure
import pytest
from unittest.mock import patch, MagicMock
from fastapi.testclient import TestClient
from scripts.server import app

client = TestClient(app)

class TestHealthEndpoint:
    def test_health_returns_ok(self):
        response = client.get("/api/v1/health")
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "ok"
        assert "version" in data
        assert "uptime_seconds" in data

class TestProfileEndpoints:
    @patch("scripts.profile_routes.list_profiles")
    def test_list_profiles(self, mock_list):
        mock_list.return_value = ["default", "acme"]
        response = client.get("/api/v1/profiles")
        assert response.status_code == 200
        assert "default" in response.json()["profiles"]

    @patch("scripts.profile_routes.load_profile")
    def test_get_profile_not_found(self, mock_load):
        from scripts.auth import CredentialsNotFoundError
        mock_load.side_effect = CredentialsNotFoundError("nope")
        response = client.get("/api/v1/profiles/nonexistent")
        assert response.status_code == 404

class TestDiscoveryEndpoints:
    @patch("scripts.discovery_routes.full_discovery")
    @patch("scripts.discovery_routes.get_client")
    def test_full_discovery(self, mock_client, mock_discovery):
        mock_client.return_value = MagicMock(org_id="123")
        mock_discovery.return_value = MagicMock()
        response = client.post("/api/v1/discovery/full",
                               json={"client_name": "test"})
        assert response.status_code == 200

class TestErrorHandlers:
    def test_credentials_not_found_returns_404(self):
        """Verify exception → HTTP 404 mapping."""
        ...

    def test_meraki_api_error_returns_502(self):
        """Verify Meraki API exception → HTTP 502 mapping."""
        ...
```

Run tests: `pytest tests/test_server.py -v`

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-05 | 0.1.0 | Story created from PRD + Architecture | River (SM) |
| 2026-02-05 | 0.1.1 | CodeRabbit integration enabled — assertive profile, path instructions + review focus added | River (SM) |
| 2026-02-05 | 0.1.2 | Added structured Dependencies section per PO validation | River (SM) |

---

## Dev Agent Record

### Agent Model Used
_(To be filled by dev agent)_

### Debug Log References
_(To be filled by dev agent)_

### Completion Notes List
_(To be filled by dev agent)_

### File List
_(To be filled by dev agent)_

---

## QA Results
_(To be filled by QA agent)_
